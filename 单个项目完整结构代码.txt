È°πÁõÆ 'toolbaz-2api' ÁöÑÁªìÊûÑÊ†ë:
üìÇ toolbaz-2api/
    üìÑ .env
    üìÑ .env.example
    üìÑ Dockerfile
    üìÑ docker-compose.yml
    üìÑ main.py
    üìÑ nginx.conf
    üìÑ requirements.txt
    üìÇ app/
        üìÇ core/
            üìÑ __init__.py
            üìÑ config.py
        üìÇ providers/
            üìÑ __init__.py
            üìÑ base_provider.py
            üìÑ toolbaz_provider.py
        üìÇ utils/
            üìÑ __init__.py
            üìÑ sse_utils.py
    üìÇ static/
        üìÑ index.html
================================================================================

--- Êñá‰ª∂Ë∑ØÂæÑ: .env ---

# ====================================================================
# toolbaz-2api Áîü‰∫ßÁéØÂ¢ÉÈÖçÁΩÆ
# ====================================================================

API_MASTER_KEY=1
APP_PORT=8000

# --- ÂÖ≥ÈîÆ‰øÆÊîπ ---
# ÁΩëÁ´ôÈôêÂà∂ÊØèÂàÜÈíü5Ê¨°ËØ∑Ê±ÇÔºåÂπ∂ÂèëÊï∞ÂøÖÈ°ªËÆæ‰∏∫ 1ÔºåÂê¶ÂàôÂøÖÊä•Èîô
BROWSER_POOL_SIZE=1

CONTEXT_MAX_USES=50
LOG_LEVEL=INFO

--- Êñá‰ª∂Ë∑ØÂæÑ: .env.example ---

# ====================================================================
# toolbaz-2api Áîü‰∫ßÁéØÂ¢ÉÈÖçÁΩÆ
# ====================================================================

API_MASTER_KEY=1
APP_PORT=8000

# --- ÂÖ≥ÈîÆ‰øÆÊîπ ---
# ÁΩëÁ´ôÈôêÂà∂ÊØèÂàÜÈíü5Ê¨°ËØ∑Ê±ÇÔºåÂπ∂ÂèëÊï∞ÂøÖÈ°ªËÆæ‰∏∫ 1ÔºåÂê¶ÂàôÂøÖÊä•Èîô
BROWSER_POOL_SIZE=1

CONTEXT_MAX_USES=50
LOG_LEVEL=INFO

--- Êñá‰ª∂Ë∑ØÂæÑ: Dockerfile ---

# ‰ΩøÁî®ÂÆòÊñπ Python ÈïúÂÉè
FROM python:3.10-slim

# ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáè
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV TZ=Asia/Shanghai
# ËÆæÁΩÆ Playwright ÊµèËßàÂô®Ë∑ØÂæÑ
ENV PLAYWRIGHT_BROWSERS_PATH=/ms-playwright

WORKDIR /app

# ÂÆâË£ÖÁ≥ªÁªü‰æùËµñ
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Â§çÂà∂‰æùËµñÊñá‰ª∂
COPY requirements.txt .

# ÂÆâË£Ö Python ‰æùËµñ (‰ΩøÁî®Ê∏ÖÂçéÊ∫ê)
RUN pip install --no-cache-dir --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple && \
    pip install --no-cache-dir -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple

# ÂÆâË£Ö Playwright ÊµèËßàÂô® (Chromium)
RUN playwright install chromium --with-deps

# Â§çÂà∂Â∫îÁî®‰ª£Á†Å
COPY . .

# ÂàõÂª∫Èùû root Áî®Êà∑ (ÂÆâÂÖ®ÊúÄ‰Ω≥ÂÆûË∑µ)
RUN useradd --create-home appuser && \
    chown -R appuser:appuser /app && \
    chown -R appuser:appuser /ms-playwright

USER appuser

# Êö¥Èú≤Á´ØÂè£
EXPOSE 8000

# ÂêØÂä®ÂëΩ‰ª§
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--workers", "1"]

--- Êñá‰ª∂Ë∑ØÂæÑ: docker-compose.yml ---

services:
  app:
    build: .
    container_name: toolbaz-2api
    restart: unless-stopped
    ports:
      - "${APP_PORT:-8000}:8000"
    env_file:
      - .env
    # ÂÖ≥ÈîÆÔºöÂ¢ûÂä†ÂÖ±‰∫´ÂÜÖÂ≠òÔºåÈò≤Ê≠¢ Chromium Âú® Docker ‰∏≠Â¥©Ê∫É
    shm_size: '2gb'
    # ‰ºòÂåñ DNSÔºåÈò≤Ê≠¢Ëß£ÊûêË∂ÖÊó∂
    dns:
      - 8.8.8.8
      - 1.1.1.1
    networks:
      - toolbaz-net

networks:
  toolbaz-net:
    driver: bridge

--- Êñá‰ª∂Ë∑ØÂæÑ: main.py ---

import logging
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request, Depends, HTTPException, Header
from fastapi.responses import JSONResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware

from app.core.config import settings
from app.providers.toolbaz_provider import ToolbazProvider

# ÈÖçÁΩÆÊó•Âøó
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("toolbaz-api")

provider = ToolbazProvider()

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info(f"ÂêØÂä® {settings.APP_NAME}...")
    await provider.initialize()
    yield
    logger.info("Ê≠£Âú®ÂÖ≥Èó≠ÊµèËßàÂô®ËµÑÊ∫ê...")
    await provider.close()

app = FastAPI(title=settings.APP_NAME, version=settings.APP_VERSION, lifespan=lifespan)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ÈùôÊÄÅÊñá‰ª∂
app.mount("/static", StaticFiles(directory="static"), name="static")

async def verify_key(authorization: str = Header(None)):
    if settings.API_MASTER_KEY and settings.API_MASTER_KEY != "1":
        if not authorization or authorization != f"Bearer {settings.API_MASTER_KEY}":
            raise HTTPException(status_code=401, detail="Invalid API Key")

@app.post("/v1/chat/completions", dependencies=[Depends(verify_key)])
async def chat_completions(request: Request):
    try:
        data = await request.json()
        return await provider.chat_completion(data)
    except Exception as e:
        logger.error(f"Error: {e}")
        return JSONResponse({"error": str(e)}, status_code=500)

@app.get("/v1/models")
async def list_models():
    return await provider.get_models()

@app.get("/", response_class=HTMLResponse)
async def root():
    try:
        with open("static/index.html", "r", encoding="utf-8") as f:
            return f.read()
    except FileNotFoundError:
        return "Toolbaz-2API Running. (static/index.html not found)"

--- Êñá‰ª∂Ë∑ØÂæÑ: nginx.conf ---

worker_processes auto;
events { worker_connections 1024; }
http {
    upstream backend { server app:8080; }
    server {
        listen 80;
        server_name localhost;
        location / {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_buffering off;
            proxy_cache off;
            proxy_read_timeout 300s;
        }
    }
}

--- Êñá‰ª∂Ë∑ØÂæÑ: requirements.txt ---

fastapi
uvicorn[standard]
pydantic-settings
python-dotenv
httpx
playwright
loguru
beautifulsoup4

--- Êñá‰ª∂Ë∑ØÂæÑ: app\core\__init__.py ---



--- Êñá‰ª∂Ë∑ØÂæÑ: app\core\config.py ---

from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import List

class Settings(BaseSettings):
    # Ëøô‰∏ÄË°åÂëäËØâ Pydantic Ëá™Âä®ÂéªËØªÂèñ .env Êñá‰ª∂
    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

    APP_NAME: str = "toolbaz-2api"
    APP_VERSION: str = "3.1.0 (Full-Models)"
    
    # Â¶ÇÊûú .env ÈáåÊ≤°ÈÖç API_MASTER_KEYÔºåÈªòËÆ§Â∞±ÊòØ "1"
    API_MASTER_KEY: str = "1"
    
    # üî• ÂÆåÊï¥Ê®°ÂûãÂàóË°® (ÊÅ¢Â§ç‰∫Ü‰πãÂâçÁöÑÊâÄÊúâÊ®°Âûã)
    MODELS: List[str] = [
        "toolbaz-v4.5-fast",
        "gemini-2.5-flash",
        "gemini-2.5-pro",
        "claude-sonnet-4",
        "gpt-5",
        "grok-4-fast"
    ]
    DEFAULT_MODEL: str = "toolbaz-v4.5-fast"

    # üî• Âπ∂ÂèëÈÖçÁΩÆ (ËøôÈáåÊòØÈªòËÆ§ÂÄº) üî•
    # ËøôÈáåÁöÑ 1 ÊòØ‰∏∫‰∫ÜÈò≤Ê≠¢‰Ω†ÂøòËÆ∞ÈÖçÁΩÆ .env Êó∂Á®ãÂ∫èÊä•Èîô„ÄÇ
    # Âè™Ë¶Å‰Ω†Âú® .env ÈáåÂÜô‰∫Ü BROWSER_POOL_SIZE=5ÔºåËøôÈáåÁöÑÂÄºÂ∞±‰ºöË¢´Ë¶ÜÁõñ‰∏∫ 5„ÄÇ
    BROWSER_POOL_SIZE: int = 1
    
    # ÈªòËÆ§ÊØè‰∏™Á™óÂè£Áî® 50 Ê¨°Â∞±ÈáçÁΩÆ
    CONTEXT_MAX_USES: int = 50 

settings = Settings()

--- Êñá‰ª∂Ë∑ØÂæÑ: app\providers\__init__.py ---



--- Êñá‰ª∂Ë∑ØÂæÑ: app\providers\base_provider.py ---

from abc import ABC, abstractmethod
from typing import Dict, Any
from fastapi.responses import StreamingResponse, JSONResponse

class BaseProvider(ABC):
    @abstractmethod
    async def chat_completion(self, request_data: Dict[str, Any]) -> StreamingResponse:
        pass

    @abstractmethod
    async def get_models(self) -> JSONResponse:
        pass

--- Êñá‰ª∂Ë∑ØÂæÑ: app\providers\toolbaz_provider.py ---

import json
import time
import uuid
import asyncio
import random
import re
import html
from typing import Dict, Any, Optional, List
from fastapi import HTTPException
from fastapi.responses import StreamingResponse, JSONResponse
from playwright.async_api import async_playwright, Page, BrowserContext, Error as PlaywrightError
from loguru import logger
import httpx

from app.core.config import settings
from app.utils.sse_utils import create_sse_data, create_chat_completion_chunk, DONE_CHUNK

# --- Âçï‰∏™Â∑•‰ΩúÂçïÂÖÉ (Worker) ---
class BrowserWorker:
    """‰ª£Ë°®‰∏Ä‰∏™Áã¨Á´ãÁöÑÊµèËßàÂô®Êó†ÁóïÁ™óÂè£"""
    def __init__(self, browser):
        self.browser = browser
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.uses_count = 0
        self.created_at = 0
        self.id = str(uuid.uuid4())[:8]

    async def init(self):
        """ÂàùÂßãÂåñËøô‰∏™Á™óÂè£"""
        try:
            if self.context:
                await self.close()

            # ÂàõÂª∫Êó†Áóï‰∏ä‰∏ãÊñá
            self.context = await self.browser.new_context(
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                viewport={"width": 1920, "height": 1080},
                locale="zh-CN",
                timezone_id="Asia/Shanghai",
                java_script_enabled=True,
                bypass_csp=True,
                ignore_https_errors=True
            )
            
            self.page = await self.context.new_page()
            # Â±èËîΩ webdriver ÁâπÂæÅ
            await self.page.add_init_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined});")
            
            # È¢ÑÁÉ≠ (Â∏¶ÈáçËØïÊú∫Âà∂)
            logger.info(f"üîß [Worker-{self.id}] Ê≠£Âú®È¢ÑÁÉ≠...")
            
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    # ÈöèÊú∫Âª∂Ëøü
                    await asyncio.sleep(random.uniform(1, 2))
                    
                    await self.page.goto(
                        "https://toolbaz.com/writer/chat-gpt-alternative", 
                        wait_until="domcontentloaded", 
                        timeout=45000
                    )
                    break 
                except PlaywrightError as e:
                    if "ERR_CONNECTION_CLOSED" in str(e) or "Timeout" in str(e):
                        logger.warning(f"‚ö†Ô∏è [Worker-{self.id}] È¢ÑÁÉ≠Â§±Ë¥• (Â∞ùËØï {attempt+1}/{max_retries}): {e}")
                        if attempt == max_retries - 1:
                            raise e 
                        await asyncio.sleep(5) 
                    else:
                        raise e

            # Á®çÂæÆÂä®‰∏Ä‰∏ãÈº†Ê†á
            try:
                await self.page.mouse.move(random.randint(100, 500), random.randint(100, 500))
            except: pass
            
            self.created_at = time.time()
            self.uses_count = 0
            logger.info(f"‚úÖ [Worker-{self.id}] Â∞±Áª™")
            return True
        except Exception as e:
            logger.error(f"‚ùå [Worker-{self.id}] ÂàùÂßãÂåñÂ§±Ë¥•: {e}")
            await self.close()
            return False

    async def get_token_data(self):
        """Âú®Ëøô‰∏™ÁâπÂÆöÁ™óÂè£‰∏≠Ëé∑Âèñ Token"""
        if not self.page or self.page.is_closed():
            success = await self.init()
            if not success:
                return {"error": "Worker re-init failed"}

        try:
            await self.page.wait_for_function("typeof window.xA1pY === 'function' || typeof xA1pY === 'function'", timeout=5000)
        except:
            try:
                logger.warning(f"‚ö†Ô∏è [Worker-{self.id}] ÂáΩÊï∞Êú™Â∞±Áª™ÔºåÂ∞ùËØïÂà∑Êñ∞È°µÈù¢...")
                await self.page.reload(wait_until="domcontentloaded", timeout=30000)
                await asyncio.sleep(2)
            except Exception as e:
                return {"error": f"Reload failed: {str(e)}"}

        result = await self.page.evaluate("""() => {
            try {
                function getCookie(name) {
                    const value = `; ${document.cookie}`;
                    const parts = value.split(`; ${name}=`);
                    if (parts.length === 2) return parts.pop().split(';').shift();
                    return null;
                }
                let sessionId = getCookie("SessionID");
                if (!sessionId) {
                    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                    sessionId = "";
                    for (let i = 0; i < 36; i++) sessionId += chars.charAt(Math.floor(Math.random() * chars.length));
                    document.cookie = `SessionID=${sessionId}; path=/`;
                }
                
                let token = "";
                if (typeof window.xA1pY === 'function') token = window.xA1pY();
                else if (typeof xA1pY === 'function') token = xA1pY();
                else return { error: "xA1pY missing" };

                return { sessionId, token };
            } catch (e) { return { error: e.toString() }; }
        }""")
        
        self.uses_count += 1
        return result

    async def close(self):
        try:
            if self.context: await self.context.close()
        except: pass
        self.context = None
        self.page = None

# --- Ê†∏ÂøÉÊèê‰æõËÄÖ (Provider) ---
class ToolbazProvider:
    def __init__(self):
        self.playwright = None
        self.browser = None
        self.pool = asyncio.Queue()
        self.api_token_url = "https://data.toolbaz.com/token.php"
        self.api_writing_url = "https://data.toolbaz.com/writing.php"
        
        # üî• ÈôêÊµÅÂô®ÂèòÈáè
        self.request_timestamps: List[float] = []
        self.rate_limit_lock = asyncio.Lock()

    async def initialize(self):
        """ÂêØÂä®ÊµèËßàÂô®Âπ∂ÂàõÂª∫Ê±†Â≠ê"""
        logger.info(f"üöÄ Ê≠£Âú®ÂêØÂä®ÊµèËßàÂô®ÈõÜÁæ§ (Âπ∂ÂèëÊï∞: {settings.BROWSER_POOL_SIZE})...")
        self.playwright = await async_playwright().start()
        
        launch_args = [
            "--no-sandbox", 
            "--disable-setuid-sandbox", 
            "--disable-dev-shm-usage", 
            "--disable-gpu",
            "--disable-blink-features=AutomationControlled"
        ]
        
        self.browser = await self.playwright.chromium.launch(
            headless=True,
            args=launch_args
        )

        for i in range(settings.BROWSER_POOL_SIZE):
            worker = BrowserWorker(self.browser)
            asyncio.create_task(self._init_and_push_worker(worker))
            await asyncio.sleep(3)
        
        logger.info(f"‚úÖ ÊµèËßàÂô®Ê±†ÂêØÂä®Êåá‰ª§Â∑≤‰∏ãÂèë...")

    async def _init_and_push_worker(self, worker: BrowserWorker):
        success = await worker.init()
        if success:
            await self.pool.put(worker)
        else:
            logger.warning(f"‚ö†Ô∏è Worker-{worker.id} ÂàùÂßãÂåñÂ§±Ë¥•Ôºå10ÁßíÂêéÈáçËØï...")
            await asyncio.sleep(10)
            await self._init_and_push_worker(worker)

    async def _wait_for_rate_limit(self):
        """üî• Ê†∏ÂøÉÈôêÊµÅÈÄªËæëÔºöÁ°Æ‰øùÊØèÂàÜÈíü‰∏çË∂ÖËøá5Ê¨°ËØ∑Ê±Ç"""
        async with self.rate_limit_lock:
            current_time = time.time()
            # Ê∏ÖÁêÜË∂ÖËøá60ÁßíÁöÑÊóßËÆ∞ÂΩï
            self.request_timestamps = [t for t in self.request_timestamps if current_time - t < 60]
            
            # ÈôêÂà∂‰∏∫ÊØèÂàÜÈíü 5 Ê¨° (Áïô1Ê¨°‰ΩôÈáèÔºåËÆæ‰∏∫4Ê¨°ÊØîËæÉÂÆâÂÖ®)
            MAX_REQUESTS_PER_MINUTE = 4 
            
            if len(self.request_timestamps) >= MAX_REQUESTS_PER_MINUTE:
                # ËÆ°ÁÆóÈúÄË¶ÅÁ≠âÂæÖÁöÑÊó∂Èó¥
                oldest_request = self.request_timestamps[0]
                wait_time = 60 - (current_time - oldest_request) + 1
                if wait_time > 0:
                    logger.warning(f"üö¶ Ëß¶ÂèëÈÄüÁéáÈôêÂà∂ (5req/min)ÔºåÊ≠£Âú®ÊéíÈòüÁ≠âÂæÖ {wait_time:.2f} Áßí...")
                    await asyncio.sleep(wait_time)
            
            # ËÆ∞ÂΩïËøôÊ¨°ËØ∑Ê±ÇÁöÑÊó∂Èó¥
            self.request_timestamps.append(time.time())

    def _clean_response_text(self, text: str) -> str:
        if not text: return ""
        text = text.replace("<br>", "\n").replace("<br/>", "\n").replace("<br />", "\n")
        text = html.unescape(text)
        text = re.sub(r'^\[model:.*?\]\s*', '', text, flags=re.IGNORECASE)
        text = re.sub(r'^Toolbaz.*?:', '', text, flags=re.IGNORECASE)
        return text.strip()

    async def chat_completion(self, request_data: Dict[str, Any]):
        model = request_data.get("model", settings.DEFAULT_MODEL)
        messages = request_data.get("messages", [])
        stream = request_data.get("stream", True)
        
        last_user_content = next((m["content"] for m in reversed(messages) if m["role"] == "user"), "Hello")
        padding = "\u3164"
        formatted_text = f"{padding} : {last_user_content}{padding}"

        # 1. Ëé∑Âèñ Worker
        logger.info(f"‚è≥ Ê≠£Âú®Á≠âÂæÖÁ©∫Èó≤ÊµèËßàÂô®Á™óÂè£ (ÂΩìÂâçÂèØÁî®: {self.pool.qsize()})...")
        worker: BrowserWorker = await self.pool.get()
        
        try:
            logger.info(f"ü§ñ ‰ΩøÁî®Á™óÂè£ [Worker-{worker.id}] Â§ÑÁêÜËØ∑Ê±Ç...")
            
            if worker.uses_count > settings.CONTEXT_MAX_USES:
                logger.info(f"‚ôªÔ∏è Á™óÂè£ [Worker-{worker.id}] ‰ΩøÁî®Ê¨°Êï∞ËøáÂ§öÔºåÊ≠£Âú®ÈáçÂª∫...")
                await worker.init()

            # 2. Ëé∑ÂèñÂá≠ËØÅ
            security_data = await worker.get_token_data()
            if security_data.get("error"):
                logger.error(f"‚ùå [Worker-{worker.id}] TokenËé∑ÂèñÂ§±Ë¥•: {security_data.get('error')}")
                await worker.init()
                security_data = await worker.get_token_data()
                if security_data.get("error"):
                    raise Exception(f"TokenÁîüÊàêÂ§±Ë¥•: {security_data['error']}")

            session_id = security_data["sessionId"]
            payload_token = security_data["token"]

            # üî• 3. Âú®ÂèëÈÄÅËØ∑Ê±ÇÂâçÔºåÊâßË°åÈôêÊµÅÊ£ÄÊü•
            await self._wait_for_rate_limit()

            # 4. ÂèëÈÄÅ HTTP ËØ∑Ê±Ç
            async with httpx.AsyncClient() as client:
                headers = {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                    "Origin": "https://toolbaz.com",
                    "Referer": "https://toolbaz.com/writer/chat-gpt-alternative",
                    "X-Requested-With": "XMLHttpRequest",
                    "Cookie": f"SessionID={session_id}"
                }

                token_resp = await client.post(
                    self.api_token_url,
                    data={"session_id": session_id, "token": payload_token},
                    headers=headers,
                    timeout=20
                )
                
                if token_resp.status_code != 200:
                    raise ValueError(f"Token API Áä∂ÊÄÅÁ†ÅÈîôËØØ: {token_resp.status_code}")
                
                token_json = token_resp.json()
                if not token_json.get("success"):
                    raise ValueError(f"Token API ÊãíÁªù: {token_json}")
                
                capcha_token = token_json["token"]

                chat_resp = await client.post(
                    self.api_writing_url,
                    data={
                        "text": formatted_text,
                        "capcha": capcha_token,
                        "model": model,
                        "session_id": session_id
                    },
                    headers=headers,
                    timeout=120
                )
                
                # üî• ‰∏ìÈó®ÊçïËé∑ 400 Quota Limit ÈîôËØØ
                if chat_resp.status_code == 400 and "quota limit" in chat_resp.text:
                    logger.warning("‚ö†Ô∏è Ëß¶Âèë API Á°¨ÊÄßÈôêÊµÅÔºåËøîÂõû 429 ÁªôÂÆ¢Êà∑Á´Ø")
                    # ÂΩíËøò workerÔºåÂõ†‰∏∫ worker Êú¨Ë∫´Ê≤°ÈóÆÈ¢òÔºåÊòØ IP Ê≤°È¢ùÂ∫¶‰∫Ü
                    await self.pool.put(worker)
                    return JSONResponse({"error": "Rate limit exceeded (5 req/min). Please wait."}, status_code=429)

                if chat_resp.status_code != 200:
                    raise ValueError(f"Writing API ÈîôËØØ: {chat_resp.status_code} - {chat_resp.text[:100]}")
                
                clean_text = self._clean_response_text(chat_resp.text)
                request_id = f"chatcmpl-{uuid.uuid4()}"

                # 5. ËøîÂõûÁªìÊûú
                if not stream:
                    await self.pool.put(worker)
                    logger.info(f"üîô Á™óÂè£ [Worker-{worker.id}] Â∑≤ÂΩíËøò")
                    return JSONResponse({
                        "id": request_id,
                        "object": "chat.completion",
                        "created": int(time.time()),
                        "model": model,
                        "choices": [{"index": 0, "message": {"role": "assistant", "content": clean_text}, "finish_reason": "stop"}]
                    })

                async def stream_generator():
                    try:
                        chunk_size = 20
                        for i in range(0, len(clean_text), chunk_size):
                            part = clean_text[i:i+chunk_size]
                            yield create_sse_data(create_chat_completion_chunk(request_id, model, part))
                            await asyncio.sleep(0.02)
                        yield create_sse_data(create_chat_completion_chunk(request_id, model, "", "stop"))
                        yield DONE_CHUNK
                    finally:
                        await self.pool.put(worker)
                        logger.info(f"üîô Á™óÂè£ [Worker-{worker.id}] Â∑≤ÂΩíËøò (ÊµÅÁªìÊùü)")

                return StreamingResponse(stream_generator(), media_type="text/event-stream")

        except Exception as e:
            logger.error(f"‚ùå [Worker-{worker.id}] Â§ÑÁêÜ‰∏•ÈáçÈîôËØØ: {e}")
            asyncio.create_task(self._recycle_worker(worker))
            raise HTTPException(status_code=500, detail=str(e))

    async def _recycle_worker(self, worker: BrowserWorker):
        """ÂêéÂè∞ÂõûÊî∂Âπ∂ÈáçÁΩÆ Worker"""
        logger.info(f"üîß [Worker-{worker.id}] Ê≠£Âú®ÂêéÂè∞ÈáçÁΩÆ...")
        await asyncio.sleep(5)
        success = await worker.init()
        if success:
            await self.pool.put(worker)
            logger.info(f"‚úÖ [Worker-{worker.id}] ÈáçÁΩÆÊàêÂäüÂπ∂ÂΩíËøòÊ±†Â≠ê")
        else:
            logger.error(f"üíÄ [Worker-{worker.id}] ÈáçÁΩÆÂ§±Ë¥•ÔºåÂ∞ùËØïÂÜçÊ¨°ÈáçÁΩÆ...")
            await asyncio.sleep(10)
            await self._recycle_worker(worker)

    async def get_models(self):
        return JSONResponse({
            "object": "list",
            "data": [
                {"id": m, "object": "model", "created": int(time.time()), "owned_by": "toolbaz"}
                for m in settings.MODELS
            ]
        })

    async def close(self):
        while not self.pool.empty():
            worker = await self.pool.get()
            await worker.close()
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()

--- Êñá‰ª∂Ë∑ØÂæÑ: app\utils\__init__.py ---



--- Êñá‰ª∂Ë∑ØÂæÑ: app\utils\sse_utils.py ---

import json
import time
from typing import Dict, Any, Optional

DONE_CHUNK = b"data: [DONE]\n\n"

def create_sse_data(data: Dict[str, Any]) -> bytes:
    return f"data: {json.dumps(data, ensure_ascii=False)}\n\n".encode('utf-8')

def create_chat_completion_chunk(
    request_id: str,
    model: str,
    content: str,
    finish_reason: Optional[str] = None
) -> Dict[str, Any]:
    return {
        "id": request_id,
        "object": "chat.completion.chunk",
        "created": int(time.time()),
        "model": model,
        "choices": [
            {
                "index": 0,
                "delta": {"content": content},
                "finish_reason": finish_reason
            }
        ]
    }

--- Êñá‰ª∂Ë∑ØÂæÑ: static\index.html ---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toolbaz-2API ÂºÄÂèëËÄÖÈ©æÈ©∂Ëà±</title>
    <style>
        :root { --bg: #121212; --panel: #1E1E1E; --text: #E0E0E0; --primary: #00FF9D; --border: #333; }
        body { background: var(--bg); color: var(--text); font-family: 'Segoe UI', monospace; margin: 0; display: flex; height: 100vh; }
        .sidebar { width: 300px; background: var(--panel); border-right: 1px solid var(--border); padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        .main { flex: 1; padding: 20px; display: flex; flex-direction: column; }
        .box { background: #252525; padding: 15px; border-radius: 6px; border: 1px solid var(--border); }
        h2 { margin: 0 0 10px 0; color: var(--primary); font-size: 18px; }
        label { display: block; font-size: 12px; color: #888; margin-bottom: 5px; }
        input, select, textarea { width: 100%; background: #333; border: 1px solid #444; color: #fff; padding: 8px; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px; font-family: inherit; }
        button { width: 100%; padding: 10px; background: var(--primary); border: none; border-radius: 4px; color: #000; font-weight: bold; cursor: pointer; }
        button:hover { opacity: 0.9; }
        button:disabled { background: #555; cursor: not-allowed; }
        .chat-box { flex: 1; background: #000; border: 1px solid var(--border); border-radius: 6px; padding: 15px; overflow-y: auto; margin-bottom: 15px; font-size: 14px; line-height: 1.6; }
        .msg { margin-bottom: 10px; padding: 10px; border-radius: 4px; max-width: 80%; }
        .msg.user { background: #333; align-self: flex-end; margin-left: auto; }
        .msg.ai { background: #1a1a1a; border: 1px solid #333; }
        .status { font-size: 12px; color: #888; margin-top: auto; text-align: center; }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="box">
            <h2>üöÄ Toolbaz-2API</h2>
            <div style="font-size: 12px; color: #aaa;">Docker ÈìÅÁî≤Ëà∞Áâà v2.1</div>
        </div>
        <div class="box">
            <label>API Key</label>
            <input type="password" id="apiKey" value="1">
            <label>Ê®°Âûã</label>
            <select id="model">
                <option value="toolbaz-v4.5-fast">toolbaz-v4.5-fast</option>
                <option value="gemini-2.5-flash">gemini-2.5-flash</option>
                <option value="gpt-5">gpt-5</option>
            </select>
        </div>
        <div class="status">
            Áä∂ÊÄÅ: <span style="color:var(--primary)">‚óè ÊµèËßàÂô®ÂºïÊìéÂ∞±Áª™</span>
        </div>
    </div>
    <div class="main">
        <div class="chat-box" id="chatBox">
            <div class="msg ai">Á≥ªÁªüÂ∑≤Â∞±Áª™„ÄÇÊàëÊòØÂü∫‰∫é Playwright È©±Âä®ÁöÑ Toolbaz ‰ª£ÁêÜ„ÄÇËØ∑ÊèêÈóÆ...</div>
        </div>
        <div style="display:flex; gap:10px;">
            <textarea id="prompt" rows="1" placeholder="ËæìÂÖ•Ê∂àÊÅØ..." style="margin:0;"></textarea>
            <button style="width:100px; margin:0;" onclick="send()" id="btn">ÂèëÈÄÅ</button>
        </div>
    </div>

    <script>
        async function send() {
            const prompt = document.getElementById('prompt').value;
            if(!prompt) return;
            
            const chatBox = document.getElementById('chatBox');
            const btn = document.getElementById('btn');
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('model').value;

            chatBox.innerHTML += `<div class="msg user">${prompt}</div>`;
            document.getElementById('prompt').value = '';
            btn.disabled = true;
            btn.innerText = "ÁîüÊàê‰∏≠...";

            const aiMsg = document.createElement('div');
            aiMsg.className = 'msg ai';
            aiMsg.innerText = "‚ñã";
            chatBox.appendChild(aiMsg);
            chatBox.scrollTop = chatBox.scrollHeight;

            try {
                const res = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{role: "user", content: prompt}],
                        stream: true
                    })
                });

                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let fullText = "";

                while(true) {
                    const {done, value} = await reader.read();
                    if(done) break;
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    for(const line of lines) {
                        if(line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if(data === '[DONE]') break;
                            try {
                                const json = JSON.parse(data);
                                const content = json.choices[0].delta.content;
                                if(content) {
                                    fullText += content;
                                    aiMsg.innerText = fullText + "‚ñã";
                                    chatBox.scrollTop = chatBox.scrollHeight;
                                }
                            } catch(e){}
                        }
                    }
                }
                aiMsg.innerText = fullText;
            } catch(e) {
                aiMsg.innerText += `\n[ÈîôËØØ: ${e.message}]`;
                aiMsg.style.color = "#ff5555";
            } finally {
                btn.disabled = false;
                btn.innerText = "ÂèëÈÄÅ";
            }
        }
    </script>
</body>
</html>


